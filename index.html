<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8" />
<title>Гра з рівнями і боєм</title>
<style>
  body { margin:0; overflow:hidden; background: #333; font-family: monospace; }
  canvas { display:block; margin: 0 auto; background: #87ceeb; }
  #info { color: white; text-align: center; margin: 10px; }
</style>
</head>
<body>

<canvas id="game" width="800" height="400"></canvas>
<div id="info">Рух: WASD або стрілки. Ліва кнопка миші — удар. Вбивай ворогів, йди у портал!</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const tileSize = 40;
const cols = Math.floor(canvas.width / tileSize);
const rows = Math.floor(canvas.height / tileSize);

const AIR = 0, GROUND = 1;
const colors = {
  [AIR]: null,
  [GROUND]: '#654321'
};

let keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

let mouseDown = false;
window.addEventListener('mousedown', e => mouseDown = true);
window.addEventListener('mouseup', e => mouseDown = false);

// Світ - земля по низу
let world = [];
for(let r=0; r<rows; r++) {
  world[r] = [];
  for(let c=0; c<cols; c++) {
    world[r][c] = (r >= rows - 2) ? GROUND : AIR;
  }
}

const player = {
  x: tileSize * 2,
  y: (rows - 3) * tileSize,
  w: 30,
  h: 35,
  vx: 0,
  vy: 0,
  speed: 4,
  grounded: false,
  hp: 100,
  attackCooldown: 0,
  facing: 1
};

function isSolid(r,c) {
  return r>=0 && r<rows && c>=0 && c<cols && world[r][c] === GROUND;
}

function collideRect(a,b) {
  return !(a.x + a.w < b.x || a.x > b.x + b.w ||
           a.y + a.h < b.y || a.y > b.y + b.h);
}

const enemies = [];
function spawnEnemy(x,y) {
  enemies.push({
    x, y, w: 30, h: 35, vx: 1, hp: 20, attackCooldown: 0
  });
}

let currentLevel = 0;

const levels = [
  {
    enemies: [{x: 400, y: (rows-3)*tileSize}],
    portalX: 750,
    portalY: (rows-3)*tileSize - 35,
  },
  {
    enemies: [{x: 300, y: (rows-3)*tileSize}, {x: 600, y: (rows-3)*tileSize}],
    portalX: 750,
    portalY: (rows-3)*tileSize - 35,
  },
  {
    enemies: [{x: 350, y: (rows-3)*tileSize}, {x: 500, y: (rows-3)*tileSize}, {x: 650, y: (rows-3)*tileSize}],
    portalX: 750,
    portalY: (rows-3)*tileSize - 35,
  }
];

function loadLevel(levelNum) {
  enemies.length = 0;
  const lvl = levels[levelNum];
  lvl.enemies.forEach(e => spawnEnemy(e.x, e.y));
  player.x = tileSize * 2;
  player.y = (rows - 3) * tileSize;
  player.hp = 100;
}

loadLevel(currentLevel);

function updatePlayer() {
  player.vx = 0;
  if(keys['a'] || keys['arrowleft']) { player.vx = -player.speed; player.facing = -1; }
  if(keys['d'] || keys['arrowright']) { player.vx = player.speed; player.facing = 1; }

  if((keys['w'] || keys['arrowup'] || keys[' ']) && player.grounded) {
    player.vy = -15;
    player.grounded = false;
  }

  player.vy += 1;
  if(player.vy > 20) player.vy = 20;

  player.x += player.vx;
  let leftCol = Math.floor(player.x / tileSize);
  let rightCol = Math.floor((player.x + player.w) / tileSize);
  let topRow = Math.floor(player.y / tileSize);
  let bottomRow = Math.floor((player.y + player.h) / tileSize);

  if(player.vx > 0) {
    if(isSolid(topRow,rightCol) || isSolid(bottomRow,rightCol)) {
      player.x = rightCol * tileSize - player.w - 0.01;
    }
  } else if(player.vx < 0) {
    if(isSolid(topRow,leftCol) || isSolid(bottomRow,leftCol)) {
      player.x = (leftCol + 1) * tileSize + 0.01;
    }
  }

  player.y += player.vy;
  topRow = Math.floor(player.y / tileSize);
  bottomRow = Math.floor((player.y + player.h) / tileSize);

  if(player.vy > 0) {
    if(isSolid(bottomRow,leftCol) || isSolid(bottomRow,rightCol)) {
      player.y = bottomRow * tileSize - player.h - 0.01;
      player.vy = 0;
      player.grounded = true;
    } else {
      player.grounded = false;
    }
  } else if(player.vy < 0) {
    if(isSolid(topRow,leftCol) || isSolid(topRow,rightCol)) {
      player.y = (topRow + 1) * tileSize + 0.01;
      player.vy = 0;
    }
  }

  if(player.x < 0) player.x = 0;
  if(player.x + player.w > canvas.width) player.x = canvas.width - player.w;
  if(player.y > canvas.height) {
    player.hp = 0;
  }

  if(player.attackCooldown > 0) player.attackCooldown--;

  if(mouseDown && player.attackCooldown === 0) {
    player.attackCooldown = 20;
    attack();
  }
}

function attack() {
  const attackRange = {
    x: player.facing === 1 ? player.x + player.w : player.x - 40,
    y: player.y,
    w: 40,
    h: player.h
  };
  ctx.fillStyle = 'rgba(255,255,0,0.5)';
  ctx.fillRect(attackRange.x, attackRange.y, attackRange.w, attackRange.h);

  enemies.forEach(e => {
    if(e.hp > 0 && collideRect(attackRange, e)) {
      e.hp -= 10;
    }
  });
}

function updateEnemies() {
  enemies.forEach(e => {
    if(e.hp <= 0) return;

    e.x += e.vx;
    if(e.x < 0 || e.x + e.w > canvas.width) e.vx *= -1;

    if(collideRect(e, player)) {
      if(e.attackCooldown === 0) {
        player.hp -= 5;
        e.attackCooldown = 50;
      }
    }
    if(e.attackCooldown > 0) e.attackCooldown--;
  });

  for(let i = enemies.length -1; i >=0; i--) {
    if(enemies[i].hp <= 0) enemies.splice(i,1);
  }
}

function drawWorld() {
  for(let r=0; r<rows; r++) {
    for(let c=0; c<cols; c++) {
      if(world[r][c] === GROUND) {
        ctx.fillStyle = colors[GROUND];
        ctx.fillRect(c*tileSize, r*tileSize, tileSize, tileSize);
      }
    }
  }
}

function drawPlayer() {
  ctx.fillStyle = '#ff0';
  ctx.fillRect(player.x, player.y, player.w, player.h);
}

function drawEnemies() {
  enemies.forEach(e => {
    if(e.hp > 0) {
      ctx.fillStyle = 'red';
      ctx.fillRect(e.x, e.y, e.w, e.h);
      ctx.fillStyle = 'green';
      ctx.fillRect(e.x, e.y - 6, e.w * (e.hp/20), 4);
    }
  });
}

function drawPortal() {
  ctx.fillStyle = 'purple';
  const p = levels[currentLevel].portalX;
  const py = levels[currentLevel].portalY;
  ctx.fillRect(p, py, 40, 40);
}

function checkPortal() {
  const p = levels[currentLevel].portalX;
  const py = levels[currentLevel].portalY;
  const portalRect = {x: p, y: py, w: 40, h: 40};
  const playerRect = {x: player.x, y: player.y, w: player.w, h: player.h};
  if(enemies.length === 0 && collideRect(playerRect, portalRect)) {
    currentLevel++;
    if(currentLevel >= levels.length) {
      alert('Ви пройшли всі рівні! Вітаю!');
      currentLevel = 0;
    }
    loadLevel(currentLevel);
  }
}

function drawHP() {
  ctx.fillStyle = 'white';
  ctx.font = '18px monospace';
  ctx.fillText('Здоров\'я: ' + player.hp, 10, 25);
}

function gameOver() {
  ctx.fillStyle = 'black';
  ctx.globalAlpha = 0.7;
  ctx.fillRect(0,0,canvas.width, canvas.height);
  ctx.globalAlpha = 1;
  ctx.fillStyle = 'red';
  ctx.font = '48px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
}

function update() {
  if(player.hp <= 0) {
    draw();
    gameOver();
    return;
  }
  updatePlayer();
  updateEnemies();
  checkPortal();
  draw();
  requestAnimationFrame(update);
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawWorld();
  drawPlayer();
  drawEnemies();
  drawPortal();
  drawHP();
}

update();

</script>

</body>
</html>
