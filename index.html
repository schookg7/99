<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8" />
<title>Pixel World — 50 рівнів</title>
<style>
  body { margin: 0; overflow: hidden; background: #87ceeb; }
  canvas { display: block; margin: 0 auto; background: #6b8e23; }
  #ui {
    position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
    background: rgba(0,0,0,0.7); padding: 5px 15px; border-radius: 8px; color: white; font-family: monospace;
  }
  #levelNum { font-weight: bold; }
</style>
</head>
<body>

<canvas id="game" width="800" height="400"></canvas>
<div id="ui">Рівень: <span id="levelNum">1</span></div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const tileSize = 40;
const cols = Math.floor(canvas.width / tileSize);
const rows = Math.floor(canvas.height / tileSize);

const AIR = 0, GRASS = 1, DIRT = 2, STONE = 3;
const blockColors = {
  [AIR]: null,
  [GRASS]: '#228B22',
  [DIRT]: '#8B4513',
  [STONE]: '#888'
};

// Генеруємо 50 рівнів зростаючої складності
const levels = [];
for(let lvl=1; lvl<=50; lvl++) {
  const map = [];
  for(let r=0; r<rows; r++) {
    map[r] = [];
    for(let c=0; c<cols; c++) {
      if (r > rows - 3) map[r][c] = DIRT;
      else if (r === rows - 3) map[r][c] = GRASS;
      else map[r][c] = AIR;
    }
  }
  // Додаємо перешкоди: чим вищий рівень, тим більше блоків на рівні
  const obstaclesCount = Math.min(lvl * 2, cols * 3);
  for(let i=0; i<obstaclesCount; i++) {
    const r = rows - 4 - Math.floor(Math.random() * 3);
    const c = Math.floor(Math.random() * cols);
    map[r][c] = STONE;
  }
  levels.push(map);
}

// Вороги: кожен рівень має ворогів, кількість зростає з рівнем
function generateEnemies(level) {
  const enemies = [];
  const count = Math.min(level * 1, 10);
  for(let i=0; i<count; i++) {
    enemies.push({
      x: Math.random() * (canvas.width - tileSize),
      y: (rows - 4) * tileSize,
      w: 30,
      h: 30,
      vx: (Math.random() > 0.5 ? 1 : -1) * (1 + level*0.1),
      hp: 3 + level,
    });
  }
  return enemies;
}

// Босс (50 рівень)
const boss = {
  x: canvas.width / 2 - 50,
  y: (rows - 5) * tileSize,
  w: 100,
  h: 80,
  hp: 200,
  vx: 2,
  direction: 1,
  alive: true
}

// Гравець
const player = {
  x: tileSize * 2,
  y: (rows - 4) * tileSize,
  w: 30,
  h: 35,
  vx: 0,
  vy: 0,
  speed: 5,
  grounded: false,
  hp: 100,
};

let currentLevel = 1;
let world = levels[currentLevel - 1];
let enemies = generateEnemies(currentLevel);

const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

function isSolid(r,c) {
  return r>=0 && r<rows && c>=0 && c<cols && world[r][c] !== AIR;
}

// Фізика і рух гравця
function updatePlayer() {
  // Горизонтальний рух
  if(keys['a'] || keys['arrowleft']) player.vx = -player.speed;
  else if(keys['d'] || keys['arrowright']) player.vx = player.speed;
  else player.vx = 0;

  // Стрибок
  if((keys['w'] || keys['arrowup'] || keys[' ']) && player.grounded) {
    player.vy = -15;
    player.grounded = false;
  }

  // Гравітація
  player.vy += 1;
  if(player.vy > 20) player.vy = 20;

  // Рух по Х
  player.x += player.vx;
  // Колізії по Х
  let leftCol = Math.floor(player.x / tileSize);
  let rightCol = Math.floor((player.x + player.w) / tileSize);
  let topRow = Math.floor(player.y / tileSize);
  let bottomRow = Math.floor((player.y + player.h) / tileSize);

  if(player.vx > 0) {
    if(isSolid(topRow,rightCol) || isSolid(bottomRow,rightCol)) {
      player.x = rightCol * tileSize - player.w - 0.01;
    }
  } else if(player.vx < 0) {
    if(isSolid(topRow,leftCol) || isSolid(bottomRow,leftCol)) {
      player.x = (leftCol + 1) * tileSize + 0.01;
    }
  }

  // Рух по Y
  player.y += player.vy;
  topRow = Math.floor(player.y / tileSize);
  bottomRow = Math.floor((player.y + player.h) / tileSize);

  if(player.vy > 0) {
    if(isSolid(bottomRow,leftCol) || isSolid(bottomRow,rightCol)) {
      player.y = bottomRow * tileSize - player.h - 0.01;
      player.vy = 0;
      player.grounded = true;
    } else player.grounded = false;
  } else if(player.vy < 0) {
    if(isSolid(topRow,leftCol) || isSolid(topRow,rightCol)) {
      player.y = (topRow + 1) * tileSize + 0.01;
      player.vy = 0;
    }
  }

  // Межі екрану
  if(player.x < 0) player.x = 0;
  if(player.x + player.w > canvas.width) player.x = canvas.width - player.w;
  if(player.y > canvas.height) {
    // Якщо впав - смерть, перезапуск рівня
    player.hp = 0;
  }
}

// Малюємо світ
function drawWorld() {
  for(let r=0; r<rows; r++) {
    for(let c=0; c<cols; c++) {
      let b = world[r][c];
      if(b !== AIR) {
        ctx.fillStyle = blockColors[b];
        ctx.fillRect(c*tileSize, r*tileSize, tileSize, tileSize);
        ctx.strokeStyle = '#444';
        ctx.strokeRect(c*tileSize, r*tileSize, tileSize, tileSize);
      }
    }
  }
}

// Малюємо гравця
function drawPlayer() {
  ctx.fillStyle = '#ff0';
  ctx.fillRect(player.x, player.y, player.w, player.h);
}

// Малюємо ворогів
function drawEnemies() {
  ctx.fillStyle = 'red';
  enemies.forEach(e => {
    if(e.hp > 0) ctx.fillRect(e.x, e.y, e.w, e.h);
  });
}

// Оновлюємо ворогів
function updateEnemies() {
  enemies.forEach(e => {
    if(e.hp <= 0) return;

    e.x += e.vx;
    if(e.x < 0 || e.x + e.w > canvas.width) e.vx *= -1;

    // Перевірка колізії з гравцем
    if(collide(player, e)) {
      player.hp -= 1;
      if(player.hp < 0) player.hp = 0;
    }
  });
}

// Колізія двох прямокутників
function collide(a,b) {
  return !(a.x + a.w < b.x || a.x > b.x + b.w ||
           a.y + a.h < b.y || a.y > b.y + b.h);
}

// Малюємо босса (на 50 рівні)
function drawBoss() {
  if(currentLevel === 50 && boss.alive) {
    ctx.fillStyle = 'purple';
    ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
  }
}

// Оновлення босса
function updateBoss() {
  if(currentLevel !== 50 || !boss.alive) return;

  boss.x += boss.vx * boss.direction;
  if(boss.x < 0) boss.direction = 1;
  if(boss.x + boss.w > canvas.width) boss.direction = -1;

  // Колізія з гравцем
  if(collide(player, boss)) {
    player.hp -= 5;
    if(player.hp < 0) player.hp = 0;
  }
}

// Перехід на наступний рівень
function nextLevel() {
  if(currentLevel === 50) {
    alert('Вітаю! Ти пройшов гру!');
    currentLevel = 1;
  } else {
    currentLevel++;
  }
  world = levels[currentLevel-1];
  enemies = generateEnemies(currentLevel);
  player.x = tileSize * 2;
  player.y = (rows - 4) * tileSize;
  player.hp = 100;
  if(currentLevel === 50) boss.alive = true;
  else boss.alive = false;

  document.getElementById('levelNum').textContent = currentLevel;
}

// Перевірка завершення рівня (дійшли до правого краю)
function checkLevelComplete() {
  if(player.x + player.w >= canvas.width - tileSize) {
    nextLevel();
  }
}

function gameOver() {
  alert('Ти програв! Спробуй ще раз.');
  currentLevel = 1;
  world = levels[0];
  enemies = generateEnemies(1);
  player.x = tileSize * 2;
  player.y = (rows - 4) * tileSize;
  player.hp = 100;
  boss.alive = false;
  document.getElementById('levelNum').textContent = currentLevel;
}

// Основний цикл гри
function gameLoop() {
  updatePlayer();
  updateEnemies();
  updateBoss();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawWorld();
  drawEnemies();
  drawPlayer();
  drawBoss();
  checkLevelComplete();

  if(player.hp <= 0) gameOver();

  requestAnimationFrame(gameLoop);
}

gameLoop();

</script>

</body>
</html>
