<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8" />
<title>Geometry Dash Покращена Версія - Повільна та Довга</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    background: #222;
    user-select: none;
    -webkit-user-select:none;
  }
  canvas {
    display: block; margin: auto;
    background: #111;
    cursor: pointer;
  }
</style>
</head>
<body>

<canvas id="game" width="800" height="400"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const WIDTH = canvas.width;
const HEIGHT = canvas.height;

const player = {
  x: 100,
  y: HEIGHT - 60,
  width: 40,
  height: 40,
  vy: 0,
  gravity: 0.8,
  jumpPower: -15,
  grounded: false,
  baseColor: '#00ffff',
  colorPulse: 0,
  colorPulseDir: 1,
  isJumping: false
};

let scrollX = 0;
const scrollSpeed = 3; // Повільніше рух

let score = 0;
let gameOver = false;

// Створимо довгий рівень з багатьма перешкодами (до 1000 по осі X)
let obstacles = [];
for(let i=400; i<=1000; i+=40) {
  // Випадкова висота перешкоди 40, 60, 80, 100
  let h = 40 + 20 * Math.floor(Math.random()*4);
  obstacles.push({
    x: i + Math.floor(Math.random()*30), // трохи рандому по X
    y: HEIGHT - h - 20,
    width: 30 + Math.floor(Math.random()*20),
    height: h
  });
}

function rectCollision(r1, r2) {
  return !(r2.x > r1.x + r1.width ||
           r2.x + r2.width < r1.x ||
           r2.y > r1.y + r1.height ||
           r2.y + r2.height < r1.y);
}

function resetGame() {
  scrollX = 0;
  score = 0;
  gameOver = false;
  player.y = HEIGHT - 60;
  player.vy = 0;
  player.grounded = false;
  player.isJumping = false;
}

function update() {
  if(gameOver) return;

  scrollX += scrollSpeed;

  player.vy += player.gravity;
  player.y += player.vy;

  if(player.y + player.height >= HEIGHT - 20) {
    player.y = HEIGHT - 20 - player.height;
    player.vy = 0;
    player.grounded = true;
    player.isJumping = false;
  } else {
    player.grounded = false;
    player.isJumping = true;
  }

  const playerRect = {x: player.x, y: player.y, width: player.width, height: player.height};
  for(let obs of obstacles) {
    const obsRect = {x: obs.x - scrollX, y: obs.y, width: obs.width, height: obs.height};
    if(rectCollision(playerRect, obsRect)) {
      gameOver = true;
    }
  }

  // Якщо пройшли рівень (scrollX більше за останню перешкоду + запас)
  if(scrollX > 1100) {
    gameOver = true;
  }

  score++;
}

function draw() {
  ctx.clearRect(0, 0, WIDTH, HEIGHT);

  // Підлога
  ctx.fillStyle = '#555';
  ctx.fillRect(0, HEIGHT - 20, WIDTH, 20);

  // Перешкоди
  ctx.fillStyle = '#e74c3c';
  for(let obs of obstacles) {
    let x = obs.x - scrollX;
    if(x + obs.width > 0 && x < WIDTH) {
      ctx.fillRect(x, obs.y, obs.width, obs.height);
    }
  }

  // Гравець
  ctx.fillStyle = player.baseColor;
  ctx.fillRect(player.x, player.y, player.width, player.height);

  // Очки
  ctx.fillStyle = 'white';
  ctx.font = '20px Arial';
  ctx.fillText('Score: ' + score, 10, 30);

  if(gameOver) {
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0,0,WIDTH,HEIGHT);
    ctx.fillStyle = 'white';
    ctx.font = '40px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', WIDTH/2, HEIGHT/2 - 20);
    ctx.font = '20px Arial';
    ctx.fillText('Click or tap to Restart', WIDTH/2, HEIGHT/2 + 20);
  }
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

function jump() {
  if(!gameOver && player.grounded) {
    player.vy = player.jumpPower;
    player.grounded = false;
    player.isJumping = true;
  }
}

canvas.addEventListener('mousedown', () => {
  if(gameOver) resetGame();
  jump();
});
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  if(gameOver) resetGame();
  jump();
}, {passive:false});

resetGame();
gameLoop();
</script>

</body>
</html>
